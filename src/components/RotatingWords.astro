---
import { getTranslation } from '../utils/i18n';

interface Props {
  words: string[];
  locale?: 'es' | 'en';
}

const { words, locale = 'es' } = Astro.props;

// Traducir según el idioma
const t = (key: string) => getTranslation(key, locale);
---

<div class="title-container flex flex-wrap justify-center items-center gap-1">
  <div class="text-white text-3xl md:text-4xl lg:text-5xl font-bold animate-fade-in animate-duration-1000">
    {t('hero-title-start')}
  </div>
  <div id="rotatingWordsContainer" class="relative h-16 md:h-20 lg:h-24 overflow-hidden min-w-[200px] md:min-w-[240px] flex items-center justify-center">
    {words.map((wordKey, index) => (
      <span 
        class={`absolute flex items-center justify-center text-3xl md:text-4xl lg:text-5xl font-bold text-primary opacity-0 transition-all duration-500 ${index === 0 ? 'active opacity-100 animate-fade-in-right animate-duration-700' : ''}`}
        data-word={t(wordKey)}
        data-index={index}
      >
        {t(wordKey)}
      </span>
    ))}
  </div>
</div>

<style>
  .text-primary {
    color: #4a90e2;
    text-shadow: 0 0 15px rgba(74, 144, 226, 0.8), 0 0 30px rgba(74, 144, 226, 0.4);
  }
</style>

<script>
  // Extender el objeto Window para TypeScript
  declare global {
    interface Window {
      [key: string]: any;
    }
  }

  // Identificador único para este componente
  const ROTATING_WORDS_ID = 'rotatingWords_' + Date.now();
  
  // Variable para el intervalo
  let rotationInterval: number | undefined;

  // Función para controlar la rotación de palabras
  function setupRotatingWords() {
    // Verificar si ya se ha inicializado
    if (window[ROTATING_WORDS_ID]) return;
    
    // Marcar como inicializado
    window[ROTATING_WORDS_ID] = true;
    
    const container = document.getElementById('rotatingWordsContainer');
    if (!container) return;
    
    const words = container.querySelectorAll('span');
    if (words.length === 0) return;
    
    // Remover cualquier función de rotación anterior si existe
    if (rotationInterval) {
      clearInterval(rotationInterval);
      rotationInterval = undefined;
    }
    
    let currentIndex = 0;
    
    // Añadir clase inicial a la primera palabra
    words[0].classList.add('animate-fade-in-right', 'animate-duration-700');
    
    // Configurar el intervalo de rotación
    rotationInterval = setInterval(() => {
      // Preparar animaciones para salida
      words[currentIndex].classList.remove('opacity-100', 'active', 'animate-fade-in-right', 'animate-duration-2000');
      words[currentIndex].classList.add('animate-fade-out-left', 'animate-duration-500');
      
      setTimeout(() => {
        words[currentIndex].classList.remove('animate-fade-out-left');
        words[currentIndex].classList.add('opacity-0');
        
        // Cambiar al siguiente índice
        currentIndex = (currentIndex + 1) % words.length;
        
        // Mostrar nueva palabra con animaciones
        words[currentIndex].classList.remove('opacity-0');
        words[currentIndex].classList.add('opacity-100', 'active', 'animate-fade-in-right', 'animate-duration-700');
        
        // Añadir efecto adicional después de que aparezca la palabra
        setTimeout(() => {
          // No añadir ningún efecto adicional para mantener la limpieza visual
        }, 700);
      }, 500);
    }, 4000);
  }
  
  // Ejecutar una sola vez cuando el DOM esté listo
  document.addEventListener('DOMContentLoaded', setupRotatingWords, { once: true });
  
  // Para compatibilidad con la navegación de Astro
  document.addEventListener('astro:page-load', setupRotatingWords, { once: true });
</script> 